"""
Workflow Contract

Defines interfaces for deterministic workflow orchestration.
Workflows enforce a clarify-plan-execute pattern: the agent always
asks clarifying questions and presents a plan before running
expensive research operations.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime


class WorkflowPhase(Enum):
    """Current phase of a workflow."""
    CLARIFY = "clarify"        # Waiting for user to answer clarifying questions
    PLAN = "plan"              # Waiting for user to approve research plan
    EXECUTE = "execute"        # Running CrewAI agents
    COMPLETED = "completed"    # Done, results available
    CANCELLED = "cancelled"    # User rejected the plan


@dataclass
class StartupContext:
    """A previously stored startup idea/project for a user."""
    id: str
    user_id: str
    name: str
    description: str
    industry: Optional[str] = None
    search_terms: Optional[List[str]] = None
    geographical_scope: Optional[List[str]] = None
    created_at: Optional[datetime] = None
    last_accessed: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None


@dataclass
class ClarifyingQuestion:
    """A question generated by the LLM to narrow research scope."""
    question: str
    context: str  # Why this question matters for focusing the research


@dataclass
class ResearchPlanStep:
    """A single step in the research plan shown to the user."""
    name: str
    description: str
    agent_role: str
    estimated_duration: Optional[str] = None


@dataclass
class ResearchPlan:
    """The research plan presented to the user before execution."""
    title: str
    steps: List[ResearchPlanStep]
    search_terms: List[str]
    geographical_scope: List[str]
    focus_areas: List[str]
    estimated_duration: Optional[str] = None
    estimated_cost: Optional[str] = None


@dataclass
class WorkflowState:
    """Full state of a workflow instance."""
    workflow_id: str
    phase: WorkflowPhase
    user_message: str
    clarifying_questions: List[ClarifyingQuestion] = field(default_factory=list)
    user_answers: Dict[str, str] = field(default_factory=dict)
    plan: Optional[ResearchPlan] = None
    results: Optional[Dict[str, Any]] = None
    startup_context: Optional[StartupContext] = None
    available_startups: Optional[List[StartupContext]] = None


class StartupContextStore(ABC):
    """
    CONTRACT: Interface for storing/retrieving user startup contexts.

    White-label implementations connect this to their database
    (Supabase, Postgres, filesystem, etc.)
    """

    @abstractmethod
    async def get_user_startups(self, user_id: str) -> List[StartupContext]:
        """Retrieve all startup ideas/projects for a user."""
        pass

    @abstractmethod
    async def get_startup_by_id(self, startup_id: str) -> Optional[StartupContext]:
        """Retrieve a specific startup context."""
        pass

    @abstractmethod
    async def save_startup(self, context: StartupContext) -> str:
        """Save or update a startup context. Returns the ID."""
        pass


class WorkflowOrchestrator(ABC):
    """
    CONTRACT: Interface for workflow orchestration.

    Enforces the clarify-plan-execute pattern:
    1. start() -> generates clarifying questions
    2. answer_questions() -> generates research plan
    3. approve_plan() -> executes research
    4. reject_plan() -> cancels workflow

    White-label implementations can override question/plan generation
    to customize the user experience.
    """

    @abstractmethod
    async def start(
        self,
        user_id: str,
        user_message: str
    ) -> WorkflowState:
        """Begin a new workflow. Returns state with clarifying questions."""
        pass

    @abstractmethod
    async def answer_questions(
        self,
        workflow_id: str,
        answers: Dict[str, str]
    ) -> WorkflowState:
        """Provide answers to clarifying questions. Returns state with plan."""
        pass

    @abstractmethod
    async def approve_plan(self, workflow_id: str) -> WorkflowState:
        """Approve the plan and execute research. Returns completed state."""
        pass

    @abstractmethod
    async def reject_plan(self, workflow_id: str) -> WorkflowState:
        """Reject the plan. Returns cancelled state."""
        pass

    @abstractmethod
    async def get_state(self, workflow_id: str) -> WorkflowState:
        """Retrieve current workflow state."""
        pass
